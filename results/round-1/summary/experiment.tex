\section{Experiment}
\label{experiment}
\subsection{Setup}
Our experimental data consists of running small programs under 4 different configurations: with contracts and the JIT enabled, with contracts disabled and the JIT enabled, with contracts enabled and JIT disabled, and finally with both contracts and JIT disabled.
We disabled the JIT using the Racket command-line flag \mono{--no-jit} and disabled contracts by editing the \mono{racket/contract} source code\textemdash wherever contracts were applied, we replaced the actual contract with a trivial \mono{any/c} contract.
See \sect{disabling-contracts} for further discussion on how we disabled contracts and the difficulties we faced, but note that we still incur the cost of making contracts (before they are discarded) and potentially incur a level of indirection for the \mono{any/c} calls even though they always accept their argument.

The 8 programs benchmarked are taken from Project Euler~\cite{project-euler} and the artifact by Nyugen et~al. on soft contracts~\cite{soft-contracts}.
We wrote the 4 Project Euler (PE) solutions ourselves and added contracts to individual functions exactly how type signatures would guard the functions statically.
These solutions were picked arbitrarily and are not solved in any particular way.\footnote{In fact, a more experienced Racketeer might cringe at our solutions.}
The 3 games we took from the soft contracts repository~\cite{soft-contracts-repo} were implemented using multiple modules.
Contracts protect module boundaries, but there are no contracts checks within any single module.

We ran each of these 8 benchmark programs on a modern desktop using Racket version 6.1.1.5 and collected the CPU time taken for the run.\footnote{CPU time was obtained by calling Racket's built-in \mono{time} function.}
To address potential outliers, we ran each benchmark 30 times on each configuration of Contracts and JIT.
Note that we started a new Racket VM for each of the 30 runs; our experiment does not measure differences between startup and steady-state performance.

\subsection{Results}
Figures~\ref{runtimes} and~\ref{speedups} document our results.
We discuss these figures in turn.

\input{fig-runtimes}

\fig{runtimes} shows the aggregate runtime for each experiment on each of the 4 configurations, normalized to the ``Contracts + JIT'' running time.
The bars additionally include their 95\% confidence interval.
The confidence intervals suggest minimal variation among the 30 trials.
This suggests that our benchmarks are ``well-behaved'' in the sense that both contract overhead and JIT optimizations apply uniformly across trials, and that we are justified in extrapolating our data to more general settings.

From this chart, we conclude that contracts are responsible for at least an order of magnitude slowdown under normal execution.
With the JIT disabled, the runnning-time effects of contracts are generally less severe but still significant.
We also conclude that the JIT is responsible for large speedups regardless of whether contracts are on or off.
Regarding the individual projects, we first note that our solution to Project Euler \#46 apparantly contains much redundant, or at least ``hot'', computation.
Snake and Tetris, from the soft contracts repo, also finish very quickly with contracts disabled.
However these benchmarks were divided into quite small modules, and may not be indicative of the contract overhead one might see naturally.

\newpage
\input{fig-speedups}

\fig{speedups} shows the percent difference in runtimes with JIT enabled versus those with JIT disabled.
The two charts in this figure measure the increases with and without contracts, respectively.
Each chart displays the precise data for each of the 30 trials, so we can see the variation between measurements on an absolute scale.

Besides \#46, all the Project Euler solutions exhibit a large, consistent speedup after removing contracts.
Thus we conclude that the contracts hindered the JIT's ability to optimize (despite offering more ``redundant computation'' to potentially reduce).
The anomalous program, problem 46, is consistently optimized.
This makes sense considering the amount of redundant computation it contains.

The soft contracts benchmarks are a little more interesting.
Tetris is similar to our Project Euler benchmarks in that it clearly optimizes better without contracts.
On the other hand Zombie, the benchmark using the most higher-order contracts, is optimized relatively poorly regardless of whether contracts are erased.
In the case of no contracts these optimizations take effect more unpredictably.
These results suggest that an object-oriented style of programming is less amenable to the Racket JIT's optimizations.
Finally, Snake has the strangest results.
On average, the JIT optimizes more with contracts disabled; however, the magnitude of these optimizations is more variable.
We do not have a good explanation for this result.
Intuitively, Snake should behave like Tetris as both use a random number generator for small game components (spawning new items / pieces) and are coded as traditional functional programs.

To summarize, our results suggest that the JIT optimizes better on programs with fewer contracts.
This is modestly suprising because we consider contracts to be redundant computation, however the changes they cause to a program's execution pattern apparently bear a significant cost.

